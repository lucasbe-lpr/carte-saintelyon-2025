<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Parcours Saint√©Lyon 2025</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet"/>

  <style>
    /* --- CONFIGURATION CSS ---
       J'utilise des variables CSS pour g√©rer le th√®me (clair/sombre) facilement.
       Le namespace #lyon-widget est vital pour ne pas que le CSS de mon site parent
       vienne casser le style de l'iframe.
    */
    #lyon-widget {
      --lw-bg: #FFFFFF; --lw-bg-alt: #F8F9FA; --lw-text: #212529; --lw-muted: #6C757D;
      --lw-accent: #212529; --lw-orange: #E65100; --lw-border: #DEE2E6; --lw-radius: 8px;
      --lw-font-main: 'Roboto', sans-serif;
    }
    
    /* Mode sombre activ√© via JS */
    #lyon-widget.lw-dark {
        --lw-bg: #1A1A1A; --lw-bg-alt: #252525; --lw-text: #E9ECEF; --lw-muted: #ADB5BD;
        --lw-accent: #FFFFFF; --lw-border: #343A40;
    }
    
    /* --- LAYOUT & RESET ---
       Important : html/body √† 100% et overflow hidden pour que l'app se comporte
       comme une "carte" fixe et pas comme une page web qui scroll.
    */
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden; background-color: transparent; }
    
    #lyon-widget {
        font-family: var(--lw-font-main); color: var(--lw-text);
        width: 100%; height: 100%; 
        display: flex; flex-direction: column; 
        overflow: hidden; 
        padding: 6px; /* Petite marge pour l'ombre port√©e */
        box-sizing: border-box; 
    }

    /* Le conteneur principal (la "carte" visuelle) */
    #lyon-widget .lw-card {
        background-color: var(--lw-bg);
        border-radius: var(--lw-radius);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        flex: 1; /* Prend toute la hauteur dispo */
        overflow: hidden; 
    }

    /* --- HEADER --- */
    #lyon-widget header { padding: 12px 15px; border-bottom: 1px solid var(--lw-border); background-color: var(--lw-bg); flex-shrink: 0; }
    #lyon-widget h1 { font-size: 20px; font-weight: 700; color: var(--lw-accent); margin: 0; text-transform: uppercase; line-height: 1.2; }
    #lyon-widget .lw-subtitle { font-size: 12px; color: var(--lw-orange); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;}

    /* --- BARRE DE CONTROLE --- */
    #lyon-widget .lw-controls { 
        padding: 10px; 
        background-color: var(--lw-bg-alt); 
        border-bottom: 1px solid var(--lw-border); 
        flex-shrink: 0;
        display: flex;
        flex-direction: column; /* Pour mobile, je stack les √©l√©ments si besoin */
        gap: 8px;
    }
    
    /* Zone des boutons de parcours */
    #lyon-widget .lw-course-selector { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
    
    /* Zone des outils (Bouton profil) */
    #lyon-widget .lw-tools-selector { display: flex; justify-content: center; padding-top: 4px; border-top: 1px dashed var(--lw-border); margin-top: 4px; }

    /* Style g√©n√©rique des boutons (Pillules) */
    #lyon-widget .lw-btn {
        padding: 6px 12px; font-size: 12px; font-weight: 500; cursor: pointer; border-radius: 16px; 
        border: 1px solid var(--lw-border); background-color: var(--lw-bg); color: var(--lw-muted);
        transition: all 0.2s; display: flex; align-items: center; gap: 5px; user-select: none; white-space: nowrap;
    }
    #lyon-widget .lw-btn:hover { border-color: var(--lw-orange); color: var(--lw-orange); }
    
    /* √âtat actif du bouton */
    #lyon-widget .lw-btn.active { background-color: var(--lw-orange); color: #FFF; border-color: var(--lw-orange); font-weight: 700; }
    
    /* Le petit point de couleur dans le bouton */
    #lyon-widget .lw-btn-dot { width: 6px; height: 6px; border-radius: 50%; background-color: var(--lw-muted); }
    #lyon-widget .lw-btn.active .lw-btn-dot { background-color: #FFF; }
    
    /* --- MAP CONTAINER --- */
    /* Flex 1 est CRUCIAL ici : √ßa dit √† la map de prendre tout l'espace restant. 
       Si le graphique est cach√©, la map grandit automatiquement. */
    #lyon-widget #lw-map-wrapper { 
        position: relative; width: 100%; 
        flex: 1; 
        min-height: 150px; 
        z-index: 1; 
    }
    #lyon-widget #lw-map { width: 100%; height: 100%; background: var(--lw-bg-alt); }
    
    /* --- CHART CONTAINER (PROFIL ALTI) --- */
    #lyon-widget .lw-chart-container { 
        padding: 10px 15px 0 15px; 
        height: 200px; 
        background: var(--lw-bg); 
        border-top: 1px solid var(--lw-border);
        flex-shrink: 0; 
        display: flex; flex-direction: column;
        /* Transition fluide quand on l'affiche/masque */
        transition: height 0.3s ease, padding 0.3s ease;
    }

    /* Classe utilitaire pour masquer le graphique proprement */
    #lyon-widget .lw-chart-container.hidden {
        display: none; 
        /* Note: display: none casse l'animation CSS pure, mais c'est plus performant pour le rendu Leaflet */
    }

    #lyon-widget .lw-stats { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 5px; font-size: 12px; color: var(--lw-text); justify-content: center; }
    #lyon-widget .lw-stat-val { font-weight: 700; color: var(--lw-orange); font-family: monospace; font-size: 13px; }
    #lyon-widget canvas { flex: 1; min-height: 0; max-height: 160px; } 

    /* --- FOOTER --- */
    #lyon-widget footer { 
        padding: 8px 15px; background: var(--lw-bg-alt); border-top: 1px solid var(--lw-border); 
        display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: var(--lw-muted);
        flex-shrink: 0; 
        border-bottom-left-radius: var(--lw-radius); 
        border-bottom-right-radius: var(--lw-radius);
    }
    
    /* Gestion des arrondis en haut du widget */
    #lyon-widget header { border-top-left-radius: var(--lw-radius); border-top-right-radius: var(--lw-radius); }
    #lyon-widget .lw-controls { border-radius: 0; }
    
    /* Toggle Switch (Dark Mode) - CSS pur, pas d'images */
    #lyon-widget .lw-toggle-wrapper { display: flex; align-items: center; gap: 6px; cursor: pointer; }
    #lyon-widget .lw-switch { position: relative; width: 28px; height: 16px; background: var(--lw-border); border-radius: 20px; transition: 0.2s; }
    #lyon-widget .lw-switch::after { content: ""; position: absolute; top: 2px; left: 2px; width: 12px; height: 12px; border-radius: 50%; background: #FFF; transition: 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
    #lyon-widget input:checked + .lw-switch { background: var(--lw-orange); }
    #lyon-widget input:checked + .lw-switch::after { transform: translateX(12px); }

    /* --- MOBILE TWEAKS --- */
    @media (max-height: 600px) {
        /* Sur les petits √©crans en hauteur, je r√©duis le chart sinon on voit plus la map */
        #lyon-widget .lw-chart-container { height: 160px; }
        #lyon-widget header { padding: 8px 15px; }
    }
    
    /* --- ERROR MESSAGE --- */
    #lyon-widget .lw-error-msg {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95); border: 2px solid #E65100; padding: 15px; border-radius: 8px;
        font-size: 13px; color: #D32F2F; font-weight: bold; z-index: 2000; text-align: center; width: 80%;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: none;
    }
    #lyon-widget .lw-error-msg.active { display: block; }

    /* Correction Leaflet : pas d'arrondis sur le canvas de la map sinon √ßa bug */
    .lw-card #lw-map-wrapper { border-radius: 0; }
    .lw-card #lw-map { border-radius: 0; }

  </style>
</head>
<body>

<div id="lyon-widget">
    <div class="lw-card">
        <header>
            <div class="lw-subtitle">Saint√©Lyon 2025</div>
            <h1>Carte des parcours</h1>
        </header>

        <div class="lw-controls">
            <div class="lw-course-selector" id="course-buttons"></div>
            
            <div class="lw-tools-selector">
                <div class="lw-btn" id="btn-toggle-chart">
                    <span>üìà Afficher le profil</span>
                </div>
            </div>
        </div>

        <div id="lw-map-wrapper">
            <div id="lw-map"></div>
            <div class="lw-error-msg" id="lw-error"></div>
        </div>

        <div class="lw-chart-container hidden" id="chart-box">
            <div class="lw-stats">
                <span>Dist. <span class="lw-stat-val" id="stat-dist">-</span></span>
                <span>D+ <span class="lw-stat-val" id="stat-dplus">-</span></span>
                <span>Alt. Max <span class="lw-stat-val" id="stat-alt">-</span></span>
            </div>
            <canvas id="elevationChart"></canvas>
        </div>

        <footer> 
            <div class="lw-source-credit">Donn√©es : <b>OpenRunner</b></div>
            <label class="lw-toggle-wrapper">
                <input type="checkbox" id="lw-dark-check" style="display:none">
                <span class="lw-switch"></span>
                <span>Sombre</span>
            </label>
        </footer>
    </div>
</div>

<script>
(function() {
    // --- DATA ---
    // Les URLs pointeront vers tes fichiers .gpx r√©els.
    // J'utilise un objet cache pour ne pas ret√©l√©charger le GPX si l'utilisateur clique fr√©n√©tiquement.
    const COURSES = {
        "lyonsaintelyon": { name: "Lyon-Saint√©Lyon", url: "data/lyonsaintelyon.gpx", color: "#C900CC", cache: null },
        "saintelyon":     { name: "Saint√©Lyon",  url: "data/saintelyon.gpx",     color: "#CC0000", cache: null },
        "saintexpress":   { name: "SaintExpress",   url: "data/saintexpress.gpx",   color: "#cc7a00", cache: null },
        "saintesprint":   { name: "Saint√©Sprint",   url: "data/saintesprint.gpx",   color: "#00CCCC", cache: null },
        "saintetic":      { name: "Saint√©Tic",      url: "data/saintetic.gpx",      color: "#00CC0E", cache: null }
    };

    // --- STATE ---
    const state = { 
        map: null, 
        currentLayer: null, 
        chart: null, 
        activeCourseKey: 'saintelyon', // Parcours par d√©faut
        chartVisible: false // Par d√©faut, on masque le d√©nivel√©
    };

    // --- LOGIQUE GPX ---
    // Fonction asynchrone pour r√©cup√©rer et parser le GPX.
    async function fetchGPX(key) {
        const course = COURSES[key];
        const errorBox = document.getElementById('lw-error');
        errorBox.classList.remove('active'); 

        // Si on l'a d√©j√† en m√©moire, on √©vite la requ√™te r√©seau (perf !)
        if (course.cache) return course.cache;

        try {
            const response = await fetch(course.url); 
            if (!response.ok) throw new Error(`Fichier "${course.url}" introuvable.`);
            
            const str = await response.text();
            
            // Parsing XML classique
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(str, "text/xml");
            if (xmlDoc.querySelector("parsererror")) throw new Error("GPX mal form√©.");
            
            const trkpts = xmlDoc.getElementsByTagName("trkpt");
            if (trkpts.length === 0) throw new Error("Aucun point GPS trouv√©.");
            
            let points = [];
            // Optimisation mobile : si le GPX est √©norme (>4000 points), je garde 1 point sur 2
            // √áa √©vite de faire laguer le navigateur.
            const step = trkpts.length > 4000 ? 2 : 1;
            
            for (let i = 0; i < trkpts.length; i += step) {
                const lat = parseFloat(trkpts[i].getAttribute("lat"));
                const lon = parseFloat(trkpts[i].getAttribute("lon"));
                // Fallback √† 0 si pas d'√©l√©vation, sinon le graphique plante
                const ele = parseFloat(trkpts[i].getElementsByTagName("ele")[0]?.textContent || 0);
                points.push([lat, lon, ele]);
            }
            
            course.cache = points; // On stocke pour la prochaine fois
            return points;

        } catch (e) {
            console.error(e); // Pour le debug console
            // Affichage user-friendly de l'erreur
            errorBox.innerHTML = `‚ö†Ô∏è ${e.message}`;
            errorBox.classList.add('active');
            return [];
        }
    }

    // --- MATHS ---
    // Formule de Haversine pour calculer la distance entre deux points GPS
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Rayon terre
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Pr√©paration des donn√©es pour Chart.js
    function processDataForChart(points) {
        let distLabels = [];
        let elevations = [];
        let totalDist = 0;
        let dPlus = 0;
        let maxAlt = 0;

        for (let i = 0; i < points.length; i++) {
            if (i > 0) {
                const d = calculateDistance(points[i-1][0], points[i-1][1], points[i][0], points[i][1]);
                totalDist += d;
                // Calcul cumulatif du d√©nivel√© positif seulement
                if (points[i][2] > points[i-1][2]) dPlus += (points[i][2] - points[i-1][2]);
            }
            if (points[i][2] > maxAlt) maxAlt = points[i][2];
            
            // Downsampling pour le graphique : on ne veut pas 10 000 points dans Chart.js
            // On vise environ 150 points pour que le hover soit fluide
            const chartStep = Math.max(1, Math.floor(points.length / 150));
            if (i % chartStep === 0 || i === points.length - 1) { 
                 distLabels.push(totalDist.toFixed(1));
                 elevations.push(points[i][2]);
            }
        }
        return { 
            labels: distLabels, 
            data: elevations, 
            stats: { 
                dist: totalDist.toFixed(1), 
                dPlus: Math.round(dPlus), 
                maxAlt: Math.round(maxAlt) 
            } 
        };
    }

    let marker = null;

    // Synchronisation : quand on passe la souris sur le graphique, on bouge un point sur la carte
    function updateMapMarker(index, points, ratio) {
        // Le graphique a moins de points que la carte (downsampling), 
        // donc on utilise un ratio pour retrouver le vrai index GPS.
        const realIndex = Math.floor(index * ratio);
        const pt = points[Math.min(realIndex, points.length - 1)];
        if (!pt) return;

        if (marker) {
            marker.setLatLng([pt[0], pt[1]]);
            marker.addTo(state.map);
        } else {
            marker = L.circleMarker([pt[0], pt[1]], { 
                radius: 6, fillColor: COURSES[state.activeCourseKey].color, 
                color: "#FFF", weight: 2, opacity: 1, fillOpacity: 1 
            }).addTo(state.map);
        }
    }

    // --- MAIN LOGIC ---
    async function switchCourse(key) {
        state.activeCourseKey = key;
        const course = COURSES[key];

        // 1. Mise √† jour des boutons (Fix du bug des boutons multiples)
        // J'utilise maintenant dataset.key pour une correspondance exacte. 
        // Plus de confusion entre "Saint√©Lyon" et "Lyon-Saint√©Lyon" !
        document.querySelectorAll('.lw-btn[data-key]').forEach(b => {
            b.classList.remove('active');
            b.querySelector('.lw-btn-dot').style.backgroundColor = ''; 
            
            if (b.dataset.key === key) {
                b.classList.add('active');
                b.querySelector('.lw-btn-dot').style.backgroundColor = '#FFF';
            } else {
                // Remet la couleur originale du point si inactif
                const k = b.dataset.key;
                if(k && COURSES[k]) b.querySelector('.lw-btn-dot').style.backgroundColor = COURSES[k].color;
            }
        });

        // 2. Chargement des donn√©es
        const points = await fetchGPX(key);
        if(points.length === 0) return;

        const processed = processDataForChart(points);
        // Ratio pour la synchro carte <-> graph
        const ratio = points.length / processed.data.length;

        // 3. Update UI Stats
        document.getElementById('stat-dist').innerText = processed.stats.dist + " km";
        document.getElementById('stat-dplus').innerText = processed.stats.dPlus + " m";
        document.getElementById('stat-alt').innerText = processed.stats.maxAlt + " m";

        // 4. Dessin sur la carte
        if (state.currentLayer) state.map.removeLayer(state.currentLayer);
        const latlngs = points.map(p => [p[0], p[1]]);
        state.currentLayer = L.polyline(latlngs, { 
            color: course.color, 
            weight: 4, 
            opacity: 0.8, 
            lineJoin: 'round' 
        }).addTo(state.map);
        
        // Zoom automatique sur le parcours
        state.map.fitBounds(state.currentLayer.getBounds(), { padding: [20, 20] });

        // 5. Update du Graphique
        state.chart.data.labels = processed.labels;
        state.chart.data.datasets[0].data = processed.data;
        state.chart.data.datasets[0].borderColor = course.color;
        // Petit d√©grad√© ou transparence pour le remplissage
        state.chart.data.datasets[0].backgroundColor = hexToRgba(course.color, 0.2);
        
        // Callback Hover
        state.chart.options.onHover = (e, elements) => {
            if (elements && elements.length > 0) updateMapMarker(elements[0].index, points, ratio);
            else if(marker) marker.remove();
        };
        state.chart.update();
    }

    // Utilitaire couleur
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Gestion du bouton Toggle Profil
    function toggleChart() {
        state.chartVisible = !state.chartVisible;
        const box = document.getElementById('chart-box');
        const btnText = document.querySelector('#btn-toggle-chart span');

        if (state.chartVisible) {
            box.classList.remove('hidden');
            btnText.innerText = "üìâ Masquer le profil";
        } else {
            box.classList.add('hidden');
            btnText.innerText = "üìà Afficher le profil";
        }

        // IMPORTANT : Quand on change la taille du DOM, Leaflet perd le nord.
        // Il faut appeler invalidateSize() pour qu'il recalcule les tuiles.
        setTimeout(() => {
            state.map.invalidateSize();
            // On refit les bounds pour √™tre s√ªr que le parcours est bien centr√© dans le nouvel espace
            if (state.currentLayer) {
                state.map.fitBounds(state.currentLayer.getBounds(), { padding: [20, 20] });
            }
        }, 350); // Le d√©lai doit matcher la transition CSS (0.3s)
    }

    // --- INIT ---
    function init() {
        // Init Leaflet
        state.map = L.map('lw-map', { zoomControl: false }).setView([45.6, 4.6], 10);
        L.control.zoom({ position: 'topright' }).addTo(state.map);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OSM &copy; CARTO', subdomains: 'abcd', maxZoom: 19
        }).addTo(state.map);
        
        // Petit hack pour forcer le rendu correct au chargement
        setTimeout(() => state.map.invalidateSize(), 500); 

        // G√©n√©ration des boutons de parcours
        const btnContainer = document.getElementById('course-buttons');
        Object.keys(COURSES).forEach(key => {
            const c = COURSES[key];
            const btn = document.createElement('div');
            // J'ajoute data-key ici pour identifier formellement le bouton plus tard
            btn.className = `lw-btn`; 
            btn.dataset.key = key; 
            btn.innerHTML = `<div class="lw-btn-dot" style="background-color:${c.color}"></div> ${c.name}`;
            btn.onclick = () => switchCourse(key);
            btnContainer.appendChild(btn);
        });

        // Setup du bouton toggle chart
        document.getElementById('btn-toggle-chart').onclick = toggleChart;

        // Init Chart.js
        const ctx = document.getElementById('elevationChart').getContext('2d');
        state.chart = new Chart(ctx, {
            type: 'line',
            data: { labels: [], datasets: [{ label: 'Altitude (m)', data: [], borderWidth: 1.5, pointRadius: 0, pointHoverRadius: 6, fill: true, tension: 0.2 }] },
            options: {
                responsive: true, 
                maintainAspectRatio: false,
                plugins: { 
                    legend: { display: false }, 
                    tooltip: { 
                        mode: 'index', 
                        intersect: false,
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        titleColor: '#000',
                        bodyColor: '#333',
                        borderColor: '#ccc',
                        borderWidth: 1,
                        padding: 10,
                        titleFont: { size: 14, family: "'Roboto', sans-serif" },
                        bodyFont: { size: 13, family: "'Roboto', sans-serif" },
                        callbacks: { title: (i) => `Km ${i[0].label}`, label: (i) => `${Math.round(i.raw)} m` } 
                    } 
                },
                scales: { 
                    x: { grid: { display: false }, ticks: { maxTicksLimit: 6, font: {size: 10} } }, 
                    y: { grid: { color: 'rgba(0,0,0,0.05)' }, ticks: { font: {size: 10} } } 
                },
                interaction: { mode: 'nearest', axis: 'x', intersect: false }
            }
        });

        // Dark Mode Logic
        document.getElementById('lw-dark-check').onchange = (e) => {
            document.getElementById('lyon-widget').classList.toggle('lw-dark', e.target.checked);
            const isDark = e.target.checked;
            const textColor = isDark ? '#ADB5BD' : '#666';
            
            // On update aussi les couleurs du graph pour que ce soit lisible
            state.chart.options.scales.x.ticks.color = textColor;
            state.chart.options.scales.y.ticks.color = textColor;
            state.chart.update();

             // InvalidateSize est vital quand le conteneur change de dimension ou de style
            setTimeout(() => state.map.invalidateSize(), 100);
        };

        // On lance le premier parcours !
        switchCourse('saintelyon');
    }

    // D√©marrage au chargement du DOM
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
    else init();

})();
</script>
</body>
</html>
